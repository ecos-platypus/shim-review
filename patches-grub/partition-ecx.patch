--- ./grub-core/kern/partition.c
+++ ./grub-core/kern/partition.c
@@ -135,6 +135,7 @@
       /* Use the first partition map type found.  */
       FOR_PARTITION_MAPS(partmap)
       {
+	  grub_dprintf ("partition", "grub_partition_probe: partmap->name %s  str=<%s>\n", partmap->name, str) ;
 	if (partname_end != partname &&
 	    (grub_strncmp (partmap->name, partname, partname_end - partname)
 	     != 0 || partmap->name[partname_end - partname] != 0))
@@ -144,7 +145,10 @@
 	curpart = grub_partition_map_probe (partmap, disk, num);
 	disk->partition = tail;
 	if (curpart)
+    {
+	  grub_dprintf ("partition", "grub_partition_probe: curpart->num %d\n", curpart->number) ;
 	  break;
+    }
 
 	if (grub_errno == GRUB_ERR_BAD_PART_TABLE)
 	  {
@@ -208,6 +212,7 @@
       FOR_PARTITION_MAPS(partmap)
       {
 	grub_err_t err;
+	  grub_dprintf ("partition", "part_iterate: partition->number %d partmap->name %s\n", partition->number, partmap->name) ;
 	err = partmap->iterate (dsk, part_iterate, ctx);
 	if (err)
 	  grub_errno = GRUB_ERR_NONE;
@@ -233,6 +238,7 @@
   FOR_PARTITION_MAPS(partmap)
   {
     grub_err_t err;
+	  grub_dprintf ("partition", "grub_partition_iterate: partmap->name %s\n", partmap->name) ;
     err = partmap->iterate (disk, part_iterate, &ctx);
     if (err)
       grub_errno = GRUB_ERR_NONE;
--- ./grub-core/Makefile.core.def
+++ ./grub-core/Makefile.core.def
@@ -1974,6 +1974,11 @@
 };
 
 module = {
+  name = part_ecx;
+  common = partmap/ecx.c;
+};
+
+module = {
   name = part_msdos;
   common = partmap/msdos.c;
 };
--- ./grub-core/partmap/ecx.c	2021-09-24 12:35:42.919966780 +0200
+++ ./grub-core/partmap/ecx.c	2021-09-24 12:34:59.665589658 +0200
@@ -0,0 +1,253 @@
+/* ecx.c - Read GUID Partition Tables (ecx).  */
+/*
+ *  derived from gpt.c
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2002,2005,2006,2007,2008  Free Software Foundation, Inc.
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <grub/disk.h>
+#include <grub/misc.h>
+#include <grub/mm.h>
+#include <grub/partition.h>
+#include <grub/dl.h>
+#include <grub/msdos_partition.h>
+#include <grub/gpt_partition.h>
+#include <grub/i18n.h>
+#ifdef GRUB_UTIL
+#include <grub/emu/misc.h>
+#endif
+
+GRUB_MOD_LICENSE ("GPLv3+");
+
+static grub_uint8_t grub_ecx_magic[8] =
+  {
+    0xA5, 0x03, 0x78, 0xc9, 0x37, 0xFF, 0x00, 0xDD
+  };
+
+static const grub_guid_t grub_ecx_partition_type_empty = GRUB_GPT_PARTITION_TYPE_EMPTY;
+
+#ifdef GRUB_UTIL
+static const grub_guid_t grub_ecx_partition_type_bios_boot = GRUB_GPT_PARTITION_TYPE_BIOS_BOOT;
+#endif
+
+/* 512 << 7 = 65536 byte sectors.  */
+#define MAX_SECTOR_LOG 1
+
+static struct grub_partition_map grub_ecx_partition_map;
+
+grub_err_t
+grub_ecx_partition_map_iterate (grub_disk_t disk,
+				grub_partition_iterate_hook_t hook,
+				void *hook_data)
+{
+  struct grub_partition part;
+  struct grub_gpt_header ecx;
+  struct grub_gpt_partentry entry;
+  struct grub_msdos_partition_mbr mbr;
+  grub_uint64_t entries;
+  unsigned int i;
+  int last_offset = 0;
+  int sector_log = 0;
+  int is_gpt = 0 ;
+
+  grub_dprintf ("ecx", "ecx: try...\n");
+
+  /* Read the protective MBR.  */
+  if (grub_disk_read (disk, 0, 0, sizeof (mbr), &mbr))
+    return grub_errno;
+
+  /* Check if it is valid.  */
+  if (mbr.signature != grub_cpu_to_le16_compile_time (GRUB_PC_PARTITION_SIGNATURE))
+    return grub_error (GRUB_ERR_BAD_PART_TABLE, "no signature");
+
+  grub_dprintf ("ecx", "ecx: mbr sig ok\n");
+
+  /* Make sure the MBR is a protective MBR and not a normal MBR.  */
+  for (i = 0; i < 4; i++)
+    if (mbr.entries[i].type == GRUB_PC_PARTITION_TYPE_GPT_DISK)
+      is_gpt = 1 ;
+/*
+  if (i == 4)
+    return grub_error (GRUB_ERR_BAD_PART_TABLE, "no GPT partition map found");
+*/
+  grub_dprintf ("ecx", "ecx: is_gpt = %d\n", is_gpt);
+
+  /* Read the ecx header.  */
+  sector_log = 0 ;
+ if (grub_disk_read (disk, 0 << sector_log, 0, sizeof (ecx), &ecx))
+    return grub_errno;
+
+  grub_dprintf ("ecx", "ecx: magic %02x %02x %02x %02x\n", ecx.magic[0], ecx.magic[1], ecx.magic[2], ecx.magic[3]);
+ if (grub_memcmp (ecx.magic, grub_ecx_magic, sizeof (grub_ecx_magic)) != 0)
+    {
+    grub_dprintf ("ecx", "ecx: no header at 0\n");
+    if (grub_disk_read (disk, 2048 << sector_log, 0, sizeof (ecx), &ecx))
+        return grub_errno;
+
+    grub_dprintf ("ecx", "ecx: magic %02x %02x %02x %02x\n", ecx.magic[0], ecx.magic[1], ecx.magic[2], ecx.magic[3]);
+    if (grub_memcmp (ecx.magic, grub_ecx_magic, sizeof (grub_ecx_magic)) != 0)
+        return grub_error (GRUB_ERR_BAD_PART_TABLE, "no valid ecx header");
+    grub_dprintf ("ecx", "ecx: header at 2048\n");
+    }
+
+  grub_dprintf ("ecx", "Read a valid ecx header\n");
+
+  entries = grub_le_to_cpu64 (ecx.partitions) << sector_log;
+  for (i = 0; i < grub_le_to_cpu32 (ecx.maxpart); i++)
+    {
+      if (grub_disk_read (disk, entries, last_offset,
+			  sizeof (entry), &entry))
+	return grub_errno;
+
+      if (grub_memcmp (&grub_ecx_partition_type_empty, &entry.type,
+		       sizeof (grub_ecx_partition_type_empty)))
+	{
+	  /* Calculate the first block and the size of the partition.  */
+	  part.start = grub_le_to_cpu64 (entry.start) << sector_log;
+	  part.len = (grub_le_to_cpu64 (entry.end)
+		      - grub_le_to_cpu64 (entry.start) + 1)  << sector_log;
+	  part.offset = entries;
+	  part.number = i;
+	  part.index = last_offset;
+	  part.partmap = &grub_ecx_partition_map;
+	  part.parent = disk->partition;
+
+	  grub_dprintf ("ecx", "ecx entry %d: start=%lld, length=%lld\n", i,
+			(unsigned long long) part.start,
+			(unsigned long long) part.len);
+
+	  if (hook (disk, &part, hook_data))
+	    return grub_errno;
+	}
+
+      last_offset += grub_le_to_cpu32 (ecx.partentry_size);
+      if (last_offset == GRUB_DISK_SECTOR_SIZE)
+	{
+	  last_offset = 0;
+	  entries++;
+	}
+    }
+
+  return GRUB_ERR_NONE;
+}
+
+#ifdef GRUB_UTIL
+/* Context for ecx_partition_map_embed.  */
+struct ecx_partition_map_embed_ctx
+{
+  grub_disk_addr_t start, len;
+};
+
+/* Helper for ecx_partition_map_embed.  */
+static int
+find_usable_region (grub_disk_t disk __attribute__ ((unused)),
+		    const grub_partition_t p, void *data)
+{
+  struct ecx_partition_map_embed_ctx *ctx = data;
+  struct grub_ecx_partentry ecxdata;
+  grub_partition_t p2;
+
+  p2 = disk->partition;
+  disk->partition = p->parent;
+  if (grub_disk_read (disk, p->offset, p->index,
+		      sizeof (ecxdata), &ecxdata))
+    {
+      disk->partition = p2;
+      return 0;
+    }
+  disk->partition = p2;
+
+  /* If there's an embed region, it is in a dedicated partition.  */
+  if (! grub_memcmp (&ecxdata.type, &grub_ecx_partition_type_bios_boot, 16))
+    {
+      ctx->start = p->start;
+      ctx->len = p->len;
+      return 1;
+    }
+
+  return 0;
+}
+
+static grub_err_t
+ecx_partition_map_embed (struct grub_disk *disk, unsigned int *nsectors,
+			 unsigned int max_nsectors,
+			 grub_embed_type_t embed_type,
+			 grub_disk_addr_t **sectors,
+			 int warn_short)
+{
+  struct ecx_partition_map_embed_ctx ctx = {
+    .start = 0,
+    .len = 0
+  };
+  unsigned i;
+  grub_err_t err;
+
+  if (embed_type != GRUB_EMBED_PCBIOS)
+    return grub_error (GRUB_ERR_NOT_IMPLEMENTED_YET,
+		       "ecx currently supports only PC-BIOS embedding");
+
+  err = grub_ecx_partition_map_iterate (disk, find_usable_region, &ctx);
+  if (err)
+    return err;
+
+  if (ctx.len == 0)
+    return grub_error (GRUB_ERR_FILE_NOT_FOUND,
+		       N_("this ecx partition label contains no BIOS Boot Partition;"
+			  " embedding won't be possible"));
+
+/*
+  if (ctx.len < GRUB_MIN_RECOMMENDED_MBR_GAP)
+    grub_util_warn ("Your BIOS Boot Partition is under 1 MiB, please increase its size.");
+*/
+
+  if (ctx.len < *nsectors)
+    return grub_error (GRUB_ERR_OUT_OF_RANGE,
+		       N_("your BIOS Boot Partition is too small;"
+			  " embedding won't be possible"));
+
+  *nsectors = ctx.len;
+  if (*nsectors > max_nsectors)
+    *nsectors = max_nsectors;
+  *sectors = grub_calloc (*nsectors, sizeof (**sectors));
+  if (!*sectors)
+    return grub_errno;
+  for (i = 0; i < *nsectors; i++)
+    (*sectors)[i] = ctx.start + i;
+
+  return GRUB_ERR_NONE;
+}
+#endif
+
+
+/* Partition map type.  */
+static struct grub_partition_map grub_ecx_partition_map =
+  {
+    .name = "ecx",
+    .iterate = grub_ecx_partition_map_iterate,
+#ifdef GRUB_UTIL
+    .embed = ecx_partition_map_embed
+#endif
+  };
+
+GRUB_MOD_INIT(part_ecx)
+{
+  grub_partition_map_register (&grub_ecx_partition_map);
+}
+
+GRUB_MOD_FINI(part_ecx)
+{
+  grub_partition_map_unregister (&grub_ecx_partition_map);
+}
