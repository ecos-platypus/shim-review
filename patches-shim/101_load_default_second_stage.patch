--- a/shim.c
+++ b/shim.c
@@ -1365,6 +1365,7 @@ get_load_option_optional_data(UINT8 *data, UINTN data_size,
 	return EFI_SUCCESS;
 }
 
+/* Comment out unused function
 static int is_our_path(EFI_LOADED_IMAGE *li, CHAR16 *path)
 {
 	CHAR16 *dppath = NULL;
@@ -1393,12 +1394,14 @@ done:
 	FreePool(PathName);
 	return ret;
 }
+*/
 
 /*
  * Check the load options to specify the second stage loader
  */
-EFI_STATUS set_second_stage (EFI_HANDLE image_handle)
+EFI_STATUS set_second_stage (EFI_HANDLE image_handle UNUSED)
 {
+/* Comment out unused variables
 	EFI_STATUS efi_status;
 	EFI_LOADED_IMAGE *li = NULL;
 	CHAR16 *start = NULL;
@@ -1406,6 +1409,7 @@ EFI_STATUS set_second_stage (EFI_HANDLE image_handle)
 	CHAR16 *loader_str = NULL;
 	UINTN loader_len = 0;
 	unsigned int i;
+*/
 	UINTN second_stage_len;
 
 	second_stage_len = (StrLen(DEFAULT_LOADER) + 1) * sizeof(CHAR16);
@@ -1418,6 +1422,8 @@ EFI_STATUS set_second_stage (EFI_HANDLE image_handle)
 	load_options = NULL;
 	load_options_size = 0;
 
+// Disable dynamic second stage loader detection, always load the default loader
+#if 0
 	efi_status = gBS->HandleProtocol(image_handle, &LoadedImageProtocol,
 					 (void **) &li);
 	if (EFI_ERROR(efi_status)) {
@@ -1614,6 +1620,7 @@ EFI_STATUS set_second_stage (EFI_HANDLE image_handle)
 		load_options = remaining_size ? start + (loader_len/2) : NULL;
 		load_options_size = remaining_size;
 	}
+#endif
 
 	return EFI_SUCCESS;
 }
